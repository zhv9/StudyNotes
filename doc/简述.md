## 简单工厂模式
使用一个工厂类，来实现根据需要输出对应的实例化对象。
```csharp
public class OperationFactory{
    public static Operation createOperation(string operate){
        Operation oper = null;
        switch (operate){
            case "+":
                oper = new OperationAdd();
                break;
            case "-":
                oper = new OperationSub();
                break;
        }
        return oper;
    }
}
```

## 策略模式
使用context来配置具体使用的策略，通过每个算法实现一个抽象类，然后在context的构造函数中获取实现的算法，然后通过context中一个函数调用算法。
```csharp
abstract class Strategy{
    public abstract void AlgorithmInterface(); //  算法方法
}
// 具体算法
class ConcreteStrategyA : Strategy{
    public override void AlgorithmInterface(){
        Console.WriteLine("算法A实现");
    }
}
class ConcreteStrategyB : Strategy{
    public override void AlgorithmInterface(){
        Console.WriteLine("算法B实现");
    }
}
// 上下文
class Context{
    // 基本的策略模式
    Strategy strategy;
    public Context(Strategy strategy){
        this.strategy = strategy;
    }
    // 上下文接口
    public void ContextInterface(){
        strategy.AlgorithmInterface();
    }
}
// 策略模式+简单工厂
class CashContext{
    CashSuper cs = null;
    // 对应 Context(Strategy strategy)部分
    public CashContext(string type){
        switch (type){
            case "正常收费":
                CashNormal cs0 = new CashNomal();
                cs = cs0;
                break;
            case "满200反100":
                CashNormal cs1 = new CashReturn("200","100");
                cs = cs1
                break;
            case "打8折":
                CashNormal cs2 = new CashReturn("0.8");
                cs = cs2
                break;
        }
    }
    // 对应void ContextInterface()部分
    public double GetResult(double money){
        return cs.acceptCash(money);
    }
}
// 使用
static void Main(string[] args){
    Context context;
    context = new Context(new ConcerteStrategyA());
    context.ContextInterface();
    context = new Context(new ConcerteStrategyB());
    context.ContextInterface();
    // 实例化不同的策略，所以在最终调用时，所获得的结果就不同了。
}
```
### 简单工厂vs策略模式+简单工厂
1. 简单工厂需要客户端认识两个类
1. 策略模式+简单工厂只需要认识一个CashContext类就行了，耦合降低
```csharp
// 简单工厂
CashSuper csuper = CashFactory.creatCashAccept(cbxType.SelectedItem.ToString());
result = csuper.GetResult();
// 策略模式+简单工厂
CashSuper csuper = new CashContext(cbxType.SelectedItem.ToString());
result = csuper.GetResult();
```

### 结论
策略模式是用来封装算法的，实践中，可以用它封装任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务时，就可以考虑使用策略模式处理这种变化的可能性。
